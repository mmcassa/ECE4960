function varargout = live_plot(varargin)
%  LIVE_PLOT Live plot utility plots ASCII coded streaming data over tcpip 
%            or serial connection.
%
%     Each line of the streaming data is considered as a sample. The first
%     column is considered as a label of data. It have to match with a
%     preset keyword to be considered as a valid sample. The following
%     columns are numbered 2, 3, 4 .... Data can be extracted from these
%     columns. For example,
% 
%           TestPlot 0.001  2.641  231   0
% 
%     is a sample with keyword TestPlot. The following columns contains 4
%     numbers that available for plotting. 
% 
%     To plot data, issue a command
% 
%         live_plot(data, conn);
% 
%     to open up the plot window, where data contains description of data
%     stream and datasrc contains information about the underlying connection
%     of data.
% 
%       data.keyword    contains keyword of data to be plotted data.columns
%                       is a vector contain all the columns need to be plot
%       data.Ts         sample time of data, this is used to
%                       recover the real time vector of plot. It is assumed
%                       data comes at a constant frequecy.
%       data.Twindow    set the width of plot window in same unit as Ts.
%       data.YRange     Y direction range. Set to -1 for adaptive.
% 
%       conn.type       Type of connection 'tcpip' or 'serial'
%       conn.host       Remote host name of data, valid for 'tcpip' only.
%       conn.port       Remote tcpip port, or COM port number, in integer.
%       conn.baud       Baudrate of communication, in integer, valid for
%                       'serial' only.
%  
%   The following are autogenerated help document by GUIDE.
%  
%      LIVE_PLOT, by itself, creates a new LIVE_PLOT or raises the existing
%      singleton*.
%
%      H = LIVE_PLOT returns the handle to a new LIVE_PLOT or the handle to
%      the existing singleton*.
%
%      LIVE_PLOT('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in LIVE_PLOT.M with the given input arguments.
%
%      LIVE_PLOT('Property','Value',...) creates a new LIVE_PLOT or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before live_plot_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to live_plot_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Author: Sippey (sippey@gmail.com)
% Date: 04/16/2014

% Edit the above text to modify the response to help live_plot

% Last Modified by GUIDE v2.5 16-Apr-2014 15:46:43

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;

gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @live_plot_OpeningFcn, ...
                   'gui_OutputFcn',  @live_plot_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT

% --- Executes just before live_plot is made visible.
function live_plot_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to live_plot (see VARARGIN)

% Choose default command line output for live_plot
handles.output = hObject;

% default  data source
data_src.type = 'tcpip';
data_src.host = 'localhost';
data_src.port = 12201;
% data_src.type = 'serial';
% data_src.host = '';
% data_src.port = 3;
% data_src.baud = 115200;

% default data description
data_desc.keyword = 'Data';
data_desc.columns = [ 1 ];
data_desc.Ts = 0.02;   % zero means time is in columns(1)-1
data_desc.Twindow = 10;
data_desc.YRange = -1;

if numel(varargin) >=1
    data_desc = varargin{1};
end

if numel(varargin) >=2
    data_src = varargin{2};
end


data_desc = initialize_data(data_desc);

if strcmp(data_src.type, 'tcpip')
    set(handles.fig_plotwindow,'Name', ...
        sprintf('LIVE! PLOT %s:%d @%s [%s ]',data_src.host ,data_src.port,...
                                             data_desc.keyword, ...
                                             sprintf(' %d', data_desc.columns)));

    handles.conn = ...
        tcpip(data_src.host, data_src.port, ...
                'BytesAvailableFcn', @tcpip_BytesAvailableFcn, ...
                'BytesAvailableFcnMode', 'terminator', ...
                'Terminator', 'CR/LF' , ...
                'InputBufferSize',4096, ...
                'UserData', data_desc ...
                  );
elseif strcmp(data_src.type, 'serial')
    if ispc
        port_name = sprintf('COM%d',  data_src.port);
    elseif isunix
        port_name = sprintf('/dev/ttyS%d',  data_src.port);
    elseif ismac
        port_name = sprintf('/dev/tty.KeySerial%d',  data_src.port);
    else
        error(['Serial port ' data_src.port, ' invalid.']);
    end
    
    set(handles.fig_plotwindow,'Name', ...
        sprintf('LIVE! PLOT %s @%s [%s ]' ,port_name,...
                                             data_desc.keyword, ...
                                             sprintf(' %d', data_desc.columns)));

    handles.conn = ...
        serial(port_name, 'BaudRate', data_src.baud, ...
                'BytesAvailableFcn', @tcpip_BytesAvailableFcn, ...
                'BytesAvailableFcnMode', 'terminator', ...
                'Terminator', 'CR/LF' , ...
                'InputBufferSize',4096, ...
                'UserData', data_desc ...
                  );
else
    error(['Data source type ' data_src.type, ' is not supported.']);
end

handles.timer =...
	timer(  'TimerFcn', {@tmr_update,hObject}, ...
            'Period', 0.1, ...
            'ExecutionMode','fixedRate',...
            'UserData', handles);


% Update handles structure
guidata(hObject, handles);

% This sets up the initial plot - only do when we are invisible
% so window can get raised using live_plot.
if strcmp(get(hObject,'Visible'),'off')
    plot_data = 0;
    plot_refresh = 0;

    [plot_data, plot_refresh] = gui_plot(data_desc, handles.axes1, plot_data, plot_refresh);
    handles.plot_data = plot_data;
    handles.plot_refresh = plot_refresh;
    guidata(hObject, handles);
end

% UIWAIT makes live_plot wait for user response (see UIRESUME)
%uiwait(handles.fig_plotwindow);


% --- Outputs from this function are returned to the command line.
function varargout = live_plot_OutputFcn(hObject, eventdata, handles)
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


function [plot_data, plot_refresh] = gui_plot(data, axes, plot_data, plot_refresh)
% draw data
if plot_data
    for i=1:data.width
        set(plot_data(i), 'YData', data.data(i,:)');
    end
else
    plot_data= plot(axes, data.data');
end

% calculate range
if length(data.YRange)==2
    yrange = data.YRange;
elseif length(data.YRange)==1
    if data.YRange>0
        yrange = [-data.Range data.Range];
    else
        drange = range(data.data(:))*0.1;
        if drange<eps
            drange=1;
        end
        yrange = [min(data.data(:))-drange max(data.data(:))+drange];
    end
else
    yrange = [-1 1];
end

% draw refreshing line
if plot_refresh
    set(plot_refresh, 'XData',[data.wptr data.wptr],'YData',yrange);
else
    hold(axes,'on');
    plot_refresh = plot(axes, [data.wptr data.wptr],yrange,'r:');
    hold(axes,'off');
end

% set axis and grid
axis(axes, [1 data.size+1 yrange]);
grid(axes,'on');

% set ticks
tick = int32(linspace(1,data.size+1,11));
set(axes,'XTick',tick);
set(axes,'XTickLabel',[data.time(tick(1:end-1)) data.time(end)+data.Ts]);

function data=initialize_data(data)

data.size = data.Twindow/data.Ts;
data.width = length( data.columns);
data.data = zeros(data.width,data.size);
data.time = zeros(1,data.size);
data.wptr = 1;
data.tptr = 0;
if ~isfield(data, 'scale')
    data.multiplier = ones(data.size,1);
end
if ~isfield(data, 'YRange')
    data.YRange = -1;
end
if ~isfield(data, 'max_line')
    data.max_line = 256;
end

function tmr_update(tmr, eventdata, hObject)
handles = guidata(hObject);

data = get(handles.conn,'UserData');

gui_plot(data, handles.axes1, handles.plot_data, handles.plot_refresh);


function tcpip_BytesAvailableFcn(conn, ~)
data = get(conn,'UserData');
kw = data.keyword;
col = data.columns;
Ts = data.Ts;

line = fgetl(conn);

ss = regexp(line, '[ \t]+', 'split');
if strcmp(ss{1}, kw)
    data.data(:,data.wptr) = str2double(ss(col));
    data.time(1,data.wptr) = data.tptr;
    data.wptr = mod(data.wptr, data.size)+1;
    if Ts
       data.tptr = data.tptr + data.Ts;
    else
       data.tptr = str2double(ss{col(1)-1});
    end
end

set(conn,'UserData',data);

% --- Executes on button press in btn_save.
function btn_save_Callback(hObject, eventdata, handles)
% hObject    handle to btn_save (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
data = get(handles.conn,'UserData');
r = [ data.wptr:data.size 1:data.wptr-1];
assignin('base', 'scope_time', data.time(:,r));
assignin('base', 'scope_data', data.data(:,r));


% --- Executes on button press in btn_start.
function btn_start_Callback(hObject, eventdata, handles)
% hObject    handle to btn_start (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%fclose(handles.conn);
if (strcmp(handles.conn.Status, 'closed'))
    try
        fopen(handles.conn);
    catch
        error('Cannot open connection');
    end
    
    data = get(handles.conn,'UserData');
    data.tptr=0;
    data.wptr=1;
    set(handles.conn,'UserData',data);
end

if (strcmp(handles.timer.Running,'off'))
    start(handles.timer);
end


% --- Executes on button press in btn_redraw.
function btn_redraw_Callback(hObject, eventdata, handles)
% hObject    handle to btn_redraw (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
data = get(handles.conn,'UserData');
gui_plot(data, handles.axes1, handles.plot_data, handles.plot_refresh);

% --- Executes on button press in btn_stop.
function btn_stop_Callback(hObject, eventdata, handles)
% hObject    handle to btn_stop (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

stop(handles.timer);
fclose(handles.conn);


% --- Executes when user attempts to close fig_plotwindow.
function fig_plotwindow_CloseRequestFcn(hObject, eventdata, handles)
% hObject    handle to fig_plotwindow (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: delete(hObject) closes the figure
if isfield(handles,'conn')
    fclose(handles.conn);
    delete(handles.conn);
end
if isfield(handles,'timer')
    stop(handles.timer);
    delete(handles.timer);
end
delete(hObject);
